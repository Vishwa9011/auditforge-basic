import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import type { FsNode, Ino, InodeMeta, ResolveResult } from '../types';
import { getMeta, isDir, makeDirNode, makeFileNode } from '../lib';

/** ---- helpers to serialize Maps / Sets ---- */

function serializeFsTree(tree: Map<string, FsNode>) {
    return Array.from(tree.entries()).map(([k, v]) => [k, serializeNode(v)]);
}

function serializeNode(node: FsNode): any {
    return Array.from(node.entries()).map(([k, v]) => [k, v instanceof Map ? serializeNode(v) : v]);
}

function deserializeFsTree(data: any): Map<string, FsNode> {
    return new Map(data.map(([k, v]: any) => [k, deserializeNode(v)]));
}

function isInodeMetaLike(value: unknown): value is InodeMeta {
    if (!value || typeof value !== 'object') return false;
    const v = value as any;
    return typeof v.ino === 'number' && (v.type === 'file' || v.type === 'dir');
}

function coerceInodeMeta(value: unknown): InodeMeta | null {
    if (!isInodeMetaLike(value)) return null;
    const v = value as any;
    return {
        ino: v.ino as Ino,
        type: v.type,
        mode: typeof v.mode === 'number' ? v.mode : 511,
        mtimeMs: typeof v.mtimeMs === 'number' ? v.mtimeMs : Date.now(),
        size: typeof v.size === 'number' ? v.size : 0,
    };
}

function wrapMeta(meta: InodeMeta): FsNode {
    return new Map<string | typeof META_KEY, FsNode | InodeMeta>().set(META_KEY, meta) as FsNode;
}

function deserializeNode(data: any): FsNode {
    return new Map(
        data.map(([k, v]: any) => {
            if (Array.isArray(v)) return [k, deserializeNode(v)];
            if (k !== META_KEY) {
                const meta = coerceInodeMeta(v);
                if (meta) return [k, wrapMeta(meta)];
            }
            return [k, v];
        }),
    ) as FsNode;
}

export function resolvePath(path: string): ResolveResult {
    const fsTree = useFileSystem.getState().fsTree;
    const parts = path.split('/').filter(Boolean);

    // root
    let node = fsTree.get('/');
    if (!node) {
        return { kind: 'missing', at: '/' };
    }

    // special case: "/"
    if (parts.length === 0) {
        return { kind: 'found', node, meta: getMeta(node) };
    }

    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];

        if (!isDir(node)) {
            return { kind: 'missing', at: parts.slice(0, i).join('/') };
        }

        const next = node.get(part);
        if (!next) {
            return { kind: 'missing', at: parts.slice(0, i + 1).join('/') };
        }

        if (next instanceof Map) {
            node = next as FsNode;
            continue;
        }

        const meta = coerceInodeMeta(next);
        if (meta) {
            const wrapped = wrapMeta(meta);
            node.set(part, wrapped); // migrate legacy shape in-memory
            node = wrapped;
            continue;
        }

        return { kind: 'missing', at: parts.slice(0, i + 1).join('/') };
    }

    return { kind: 'found', node, meta: getMeta(node) };
}

export function getDirEntries(node: FsNode | InodeMeta) {
    if (!(node instanceof Map)) return [];

    const out: Array<[string, FsNode]> = [];

    for (const [key, value] of node.entries()) {
        if (key === META_KEY) continue;
        if (typeof key !== 'string') continue;

        if (value instanceof Map) {
            out.push([key, value as FsNode]);
            continue;
        }

        const meta = coerceInodeMeta(value);
        if (meta) {
            const wrapped = wrapMeta(meta);
            node.set(key, wrapped); // migrate legacy shape in-memory
            out.push([key, wrapped]);
        }
    }

    return out;
}

export function buildPath(parentPath: string, name: string) {
    if (parentPath === '/') return `/${name}`;
    return `${parentPath}/${name}`;
}

function cloneFsNode(node: FsNode): FsNode {
    return new Map(node) as FsNode;
}

function cloneDirAtPath(
    fsTree: Map<string, FsNode>,
    path: string,
): { nextTree: Map<string, FsNode>; dir: FsNode } | null {
    const rootOld = fsTree.get('/');
    if (!rootOld) return null;

    const parts = path.split('/').filter(Boolean);
    const rootNew = cloneFsNode(rootOld);

    let oldCursor: FsNode = rootOld;
    let newCursor: FsNode = rootNew;

    for (const part of parts) {
        if (!isDir(oldCursor)) return null;

        const nextOldValue = oldCursor.get(part);
        if (!nextOldValue) return null;

        const nextOld =
            nextOldValue instanceof Map
                ? (nextOldValue as FsNode)
                : (() => {
                      const meta = coerceInodeMeta(nextOldValue);
                      return meta ? wrapMeta(meta) : null;
                  })();

        if (!nextOld || !isDir(nextOld)) return null;

        const nextNew = cloneFsNode(nextOld);
        newCursor.set(part, nextNew);

        oldCursor = nextOld;
        newCursor = nextNew;
    }

    const nextTree = new Map(fsTree);
    nextTree.set('/', rootNew);

    return { nextTree, dir: newCursor };
}

/** ---- state ---- */

type FileSystemState = {
    fsTree: Map<string, FsNode>;
    nextIno: Ino;
    activeIno: Ino | null;
    openInos: Set<Ino>;

    allocateIno: () => Ino;
    setActiveIno: (ino: Ino | null) => void;
    createFile: (path: string, filename: string) => void;
    createDir: (path: string, dirname: string) => void;
    renameNode: (path: string, newName: string) => void;
    deleteNode: (path: string) => void;
};

/** ---- root creation ---- */

export const META_KEY = 0 as const;

const defaultFsTree = new Map<string, FsNode>([
    [
        '/',
        new Map()
            .set(META_KEY, makeDirNode(0 as Ino))
            .set(
                'src',
                new Map()
                    .set(META_KEY, makeDirNode(1 as Ino))
                    .set('server.ts', new Map().set(META_KEY, makeFileNode(3 as Ino))),
            )
            .set('index.ts', new Map().set(META_KEY, makeFileNode(2 as Ino))),
    ],
]);

/** ---- store ---- */

export const useFileSystem = create<FileSystemState>()(
    persist(
        (set, get) => ({
            fsTree: defaultFsTree,
            nextIno: 1 as Ino,
            activeIno: null,
            openInos: new Set<Ino>(),

            allocateIno: () => {
                const ino = get().nextIno;
                set({ nextIno: (ino + 1) as Ino });
                return ino;
            },
            setActiveIno: ino => set({ activeIno: ino }),
            createFile: (path, filename) => {
                set(state => {
                    const cloned = cloneDirAtPath(state.fsTree, path);
                    if (!cloned) return {};

                    const ino = state.nextIno;
                    cloned.dir.set(filename, wrapMeta(makeFileNode(ino)));

                    return { fsTree: cloned.nextTree, nextIno: (ino + 1) as Ino };
                });
            },
            createDir: (path, dirname) => {
                set(state => {
                    const cloned = cloneDirAtPath(state.fsTree, path);
                    if (!cloned) return {};

                    const ino = state.nextIno;
                    cloned.dir.set(dirname, new Map().set(META_KEY, makeDirNode(ino)));

                    return { fsTree: cloned.nextTree, nextIno: (ino + 1) as Ino };
                });
            },
            renameNode: (path, newName) => {
                const parent = resolvePath(path);
                console.log('parent: ', parent);
            },
            deleteNode: path => {},
        }),
        {
            name: 'file-system-storage',
            storage: createJSONStorage(() => localStorage),

            /** what gets persisted */
            partialize: state => ({
                fsTree: serializeFsTree(state.fsTree),
                nextIno: state.nextIno,
            }),

            /** how it is restored */
            merge: (persisted, current) => {
                if (!persisted) return current;

                const p = persisted as any;

                return {
                    ...current,
                    fsTree: p.fsTree ? deserializeFsTree(p.fsTree) : current.fsTree,
                    nextIno: p.nextIno ?? current.nextIno,
                };
            },
        },
    ),
);


import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import type { FsNode, Ino, InodeMeta, ResolveResult } from '../types';
import { getMeta, isDir, makeDirNode, makeFileNode } from '../lib';

/** ---- helpers to serialize Maps / Sets ---- */

function serializeFsTree(tree: Map<string, FsNode>) {
    return Array.from(tree.entries()).map(([k, v]) => [k, serializeNode(v)]);
}

function serializeNode(node: FsNode): any {
    return Array.from(node.entries()).map(([k, v]) => [k, v instanceof Map ? serializeNode(v) : v]);
}

function deserializeFsTree(data: any): Map<string, FsNode> {
    return new Map(data.map(([k, v]: any) => [k, deserializeNode(v)]));
}

function isInodeMetaLike(value: unknown): value is InodeMeta {
    if (!value || typeof value !== 'object') return false;
    const v = value as any;
    return typeof v.ino === 'number' && (v.type === 'file' || v.type === 'dir');
}

function coerceInodeMeta(value: unknown): InodeMeta | null {
    if (!isInodeMetaLike(value)) return null;
    const v = value as any;
    return {
        ino: v.ino as Ino,
        type: v.type,
        mode: typeof v.mode === 'number' ? v.mode : 511,
        mtimeMs: typeof v.mtimeMs === 'number' ? v.mtimeMs : Date.now(),
        size: typeof v.size === 'number' ? v.size : 0,
    };
}

function wrapMeta(meta: InodeMeta): FsNode {
    return new Map<string | typeof META_KEY, FsNode | InodeMeta>().set(META_KEY, meta) as FsNode;
}

function deserializeNode(data: any): FsNode {
    return new Map(
        data.map(([k, v]: any) => {
            if (Array.isArray(v)) return [k, deserializeNode(v)];
            if (k !== META_KEY) {
                const meta = coerceInodeMeta(v);
                if (meta) return [k, wrapMeta(meta)];
            }
            return [k, v];
        }),
    ) as FsNode;
}

export function resolvePath(path: string): ResolveResult {
    const fsTree = useFileSystem.getState().fsTree;
    const parts = path.split('/').filter(Boolean);

    // root
    let node = fsTree.get('/');
    if (!node) {
        return { kind: 'missing', at: '/' };
    }

    // special case: "/"
    if (parts.length === 0) {
        return { kind: 'found', node, meta: getMeta(node) };
    }

    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];

        if (!isDir(node)) {
            return { kind: 'missing', at: parts.slice(0, i).join('/') };
        }

        const next = node.get(part);
        if (!next) {
            return { kind: 'missing', at: parts.slice(0, i + 1).join('/') };
        }

        if (next instanceof Map) {
            node = next as FsNode;
            continue;
        }

        const meta = coerceInodeMeta(next);
        if (meta) {
            const wrapped = wrapMeta(meta);
            node.set(part, wrapped); // migrate legacy shape in-memory
            node = wrapped;
            continue;
        }

        return { kind: 'missing', at: parts.slice(0, i + 1).join('/') };
    }

    return { kind: 'found', node, meta: getMeta(node) };
}

export function getDirEntries(node: FsNode | InodeMeta) {
    if (!(node instanceof Map)) return [];

    const out: Array<[string, FsNode]> = [];

    for (const [key, value] of node.entries()) {
        if (key === META_KEY) continue;
        if (typeof key !== 'string') continue;

        if (value instanceof Map) {
            out.push([key, value as FsNode]);
            continue;
        }

        const meta = coerceInodeMeta(value);
        if (meta) {
            const wrapped = wrapMeta(meta);
            node.set(key, wrapped); // migrate legacy shape in-memory
            out.push([key, wrapped]);
        }
    }

    return out;
}

export function buildPath(parentPath: string, name: string) {
    if (parentPath === '/') return `/${name}`;
    return `${parentPath}/${name}`;
}

function splitPath(path: string): { parentPath: string; name: string } | null {
    const parts = path.split('/').filter(Boolean);
    const name = parts.pop();
    if (!name) return null;
    const parentPath = parts.length === 0 ? '/' : `/${parts.join('/')}`;
    return { parentPath, name };
}

function computeNextIno(fsTree: Map<string, FsNode>): Ino {
    let max = 0;

    const walk = (node: FsNode) => {
        const meta = getMeta(node);
        max = Math.max(max, meta.ino);
        for (const [key, value] of node.entries()) {
            if (key === META_KEY) continue;
            if (value instanceof Map) {
                walk(value as FsNode);
                continue;
            }
            const m = coerceInodeMeta(value);
            if (m) max = Math.max(max, m.ino);
        }
    };

    for (const [, root] of fsTree.entries()) walk(root);

    return (max + 1) as Ino;
}

function updateDirInTree(
    fsTree: Map<string, FsNode>,
    dirPath: string,
    updater: (dir: FsNode) => void,
): Map<string, FsNode> | null {
    const parts = dirPath.split('/').filter(Boolean);
    const root = fsTree.get('/');
    if (!root) return null;

    const nextRoot = new Map(root) as FsNode;

    let prevCursor: FsNode = root;
    let nextCursor: FsNode = nextRoot;

    for (const part of parts) {
        const prevValue = prevCursor.get(part);
        const prevChild = prevValue instanceof Map ? (prevValue as FsNode) : coerceInodeMeta(prevValue) ? wrapMeta(coerceInodeMeta(prevValue)!) : null;
        if (!prevChild || !isDir(prevChild)) return null;

        const nextChild = new Map(prevChild) as FsNode;
        nextCursor.set(part, nextChild);
        prevCursor = prevChild;
        nextCursor = nextChild;
    }

    if (!isDir(nextCursor)) return null;
    updater(nextCursor);

    const nextTree = new Map(fsTree);
    nextTree.set('/', nextRoot);
    return nextTree;
}

/** ---- state ---- */

type FileSystemState = {
    fsTree: Map<string, FsNode>;
    nextIno: Ino;
    activeIno: Ino | null;
    openInos: Set<Ino>;

    allocateIno: () => Ino;
    setActiveIno: (ino: Ino | null) => void;
    createFile: (path: string, filename: string) => void;
    createDir: (path: string, dirname: string) => void;
    renameNode: (path: string, newName: string) => void;
    deleteNode: (path: string) => void;
};

/** ---- root creation ---- */

export const META_KEY = 0 as const;

const defaultFsTree = new Map<string, FsNode>([
    [
        '/',
        new Map()
            .set(META_KEY, makeDirNode(0 as Ino))
            .set(
                'src',
                new Map()
                    .set(META_KEY, makeDirNode(1 as Ino))
                    .set('server.ts', new Map().set(META_KEY, makeFileNode(3 as Ino))),
            )
            .set('index.ts', new Map().set(META_KEY, makeFileNode(2 as Ino))),
    ],
]);

/** ---- store ---- */
export const useFileSystem = create<FileSystemState>()(
    persist(
        (set, get) => ({
            fsTree: defaultFsTree,
            nextIno: computeNextIno(defaultFsTree),
            activeIno: null,
            openInos: new Set<Ino>(),

            allocateIno: () => {
                const ino = get().nextIno;
                set({ nextIno: (ino + 1) as Ino });
                return ino;
            },

            setActiveIno: ino => {
                set({ activeIno: ino });
            },

            createFile: (path, filename) => {
                set(state => {
                    const ino = state.nextIno;
                    const nextFsTree = updateDirInTree(state.fsTree, path, dir => {
                        if (dir.has(filename)) return;
                        dir.set(filename, new Map().set(META_KEY, makeFileNode(ino)));
                    });
                    if (!nextFsTree) return state;
                    return { fsTree: nextFsTree, nextIno: (ino + 1) as Ino };
                });
            },

            createDir: (path, dirname) => {
                set(state => {
                    const ino = state.nextIno;
                    const nextFsTree = updateDirInTree(state.fsTree, path, dir => {
                        if (dir.has(dirname)) return;
                        dir.set(dirname, new Map().set(META_KEY, makeDirNode(ino)));
                    });
                    if (!nextFsTree) return state;
                    return { fsTree: nextFsTree, nextIno: (ino + 1) as Ino };
                });
            },

            renameNode: (path, newName) => {
                set(state => {
                    const split = splitPath(path);
                    if (!split) return state;
                    const { parentPath, name } = split;

                    const nextFsTree = updateDirInTree(state.fsTree, parentPath, dir => {
                        if (!dir.has(name)) return;
                        if (dir.has(newName)) return;
                        const node = dir.get(name);
                        if (!node) return;
                        dir.delete(name);
                        dir.set(newName, node);
                    });
                    if (!nextFsTree) return state;
                    return { fsTree: nextFsTree };
                });
            },

            deleteNode: path => {
                set(state => {
                    const split = splitPath(path);
                    if (!split) return state;
                    const { parentPath, name } = split;

                    const nextFsTree = updateDirInTree(state.fsTree, parentPath, dir => {
                        dir.delete(name);
                    });
                    if (!nextFsTree) return state;
                    return { fsTree: nextFsTree };
                });
            },
        }),
        {
            name: 'file-system-storage',
            storage: createJSONStorage(() => localStorage),
            merge: (persistedState, currentState) => {
                if (!persistedState) return currentState;

                const persisted = persistedState as unknown as Partial<{
                    fsTree: any;
                    nextIno: number;
                    activeIno: number | null;
                    openInos: number[];
                }>;

                const fsTree =
                    Array.isArray(persisted.fsTree) && persisted.fsTree.length > 0
                        ? deserializeFsTree(persisted.fsTree)
                        : currentState.fsTree;

                const openInos = new Set<Ino>(Array.isArray(persisted.openInos) ? (persisted.openInos as any) : []);

                const nextIno =
                    typeof persisted.nextIno === 'number' ? (persisted.nextIno as Ino) : currentState.nextIno;

                const activeIno =
                    typeof persisted.activeIno === 'number' ? (persisted.activeIno as Ino) : currentState.activeIno;

                return {
                    ...currentState,
                    ...persistedState,
                    fsTree,
                    openInos,
                    nextIno,
                    activeIno,
                } as FileSystemState;
            },
            partialize: state => ({
                fsTree: serializeFsTree(state.fsTree),
                nextIno: state.nextIno,
                activeIno: state.activeIno,
                openInos: Array.from(state.openInos),
            }),
        },
    ),
);

